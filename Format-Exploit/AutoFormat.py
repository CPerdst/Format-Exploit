from .logger import Logger
from pwn import *
import os
import re
import threading

lg=Logger()
lg.config_level(level=lg.debug)
lprint=lg.print
bold=lg.bold

class autoFormat():
    def __init__(self,filename=None) -> None:
        self.separator=''
        self.filename='' if not filename else filename
        self.vmmap_gadgets=[]
        self.vmmap_info={}
        self.protect_gadgets=[]
        self.protect_info={}
        self.protect_states={}
        self.task_gadgets=[]
        self.initAttr()
    # 初始化对象
    def initAttr(self):
        for i in [random.choice('abcdefghijklmnopqrstuvwxyz!@#$%^&*()') for i in range(20)]:
            self.separator+=i
        self.vmmap_gadgets=['stack','libc-2.[0-9]{1,2}.so','vvar','vdso','ld-2.[0-9]{1,2}.so']
        for gadget in self.vmmap_gadgets:
            name=re.findall('^[a-z]{2,5}',gadget)[0]
            self.vmmap_info[name]=[]
        self.protect_gadgets=['PIE','RELRO','CANARY','NX']
        for gadget in self.protect_gadgets:
            self.protect_info[gadget]=''
        self.task_gadgets=['getChecksec','getVmmap','testRun']
        self.protect_states={
            'PIE':{0:'PIE enabled',1:'No PIE'},
            'NX':{0:'NX enabled',1:'NX disabled'},
            'RELRO':{0:'Full RELRO',1:'Partial RELRO',2:'No RELRO'},
            'CANARY':{0:'Canary found',1:'No canary found'}
        }
    # 清除目前滞留的信息
    def clearText(self,p:process):
        p.sendline(f'!echo "{self.separator}"'.encode())
        res=p.recvuntil(f'{self.separator}\n'.encode())
        # lprint(res,lg.DEBUG)
    # 执行command并获取结果，info默认为False，True可以打印结果
    def command2text(self,p:process,command:str,info=False):
        self.clearText(p)
        p.sendline(command.encode())
        p.sendline(f'!echo "{self.separator}"'.encode())
        res=p.recvuntil(f'{self.separator}\n'.encode(),timeout=2)[:-1]
        if info:
            lprint(res.decode(),lg.DEBUG)
            lprint(res,lg.DEBUG)
        return res if res else None
    # 单独执行command
    def doCommand(self,p:process,command:str):
        p.sendline(command.encode())
        # lprint(f'"{command}" has executed',lg.DEBUG)
    # 获取vmmap中的信息片段
    def getFromVmmap(self,p:process,name):
        # 如果name不存在于vmmap_gadget中，报错提醒并返回
        if name not in self.vmmap_gadgets:
            lprint(f"name included in {str(self.vmmap_gadgets)}",lg.FAIL)
            return None
        # 如果vmmap_info已经初始化过，直接返回信息
        if self.vmmap_info[f'{name}']:
            return self.vmmap_info[f'{name}']
        # 初始化vmmap_info
        command='vmmap'
        command_res=self.command2text(p,command)
        for row in command_res.decode().split('\n'):
            for gadget in self.vmmap_gadgets:
                find_res=re.findall(f'{gadget}',row)
                if find_res:
                    # 获取前两个地址
                    address_res=re.findall('0x[0-9a-f]{1,12}',row)
                    # 获取权限
                    permissions_res=re.findall('r[xw-]{1,2}',row)
                    # lprint(row.encode(),lg.DEBUG)
                    clas_res=re.findall('\x1b[315[]{3,3}m',row)
                    if clas_res:
                        clas_res=clas_res[0]
                        if clas_res=='\x1b[31m':
                            clas_res='code'
                        elif clas_res=='\x1b[33m':
                            clas_res='stack'
                        elif clas_res=='\x1b[35m':
                            clas_res='data'
                    else:
                        clas_res='other'
                    # print(clas_res)
                    # 整合信息
                    info=[i for i in address_res]+permissions_res+[clas_res]
                    # 更新vmmap_info
                    name=re.findall('[a-z]{2,5}',gadget)[0]
                    self.vmmap_info[f'{name}'].append(info)
                    lprint(f'{gadget}\n{row}\n{info}',lg.DEBUG)
                    break
        # lprint(self.vmmap_info,lg.DEBUG)
        # 返回信息
        return self.vmmap_info[f'{name}']
    
    def getFromChecksec(self,p:process,name):
        # 如果name不存在于protect_gadget中，报错提醒并返回
        if name not in self.protect_gadgets:
            lprint(f"name included in {str(self.protect_gadgets)}",lg.FAIL)
            return None
        # 如果protect_info已经初始化过，直接返回信息
        if self.protect_info[f'{name}']:
            return self.protect_info[f'{name}']
        # 初始化protect_info
        command='checksec'
        command_res=self.command2text(p,command)
        command_res=command_res.decode().split('\n')[1]
        PIE_STATE=re.findall('[No ]{0,3}PIE[ enabld]{0,8}',command_res)[0]
        CANARY_STATE=re.findall('[No ]{0,3}[Cc]anary found',command_res)[0]
        RELRO_STATE=re.findall('[PartilFuNo]{0,7} RELRO',command_res)[0]
        NX_STATE=re.findall('NX [enabldis]{0,8}',command_res)[0]
        # 更新protector_info
        self.protect_info['PIE']=PIE_STATE
        self.protect_info['RELRO']=RELRO_STATE
        self.protect_info['CANARY']=CANARY_STATE
        self.protect_info['NX']=NX_STATE
        # print(CANARY_STATE)
        # print(RELRO_STATE)
        # lprint(command_res,lg.DEBUG)

    def taskFunc(self,task:str,filepath):
        # lprint(task,lg.DEBUG)
        if task not in self.task_gadgets:
            lprint(f"not included in {str(self.task_gadgets)}")
            return
        p=process(f'gdb {filepath}',shell=True)
        # self.clearText(p)
        if task == "getChecksec":
            lprint(f'getting {lg.bold("protect")} information...',lg.DEBUG)
            self.getFromChecksec(p,'PIE')
            p.close()
            if self.protect_info['PIE']: 
                lprint(f'task {lg.bold(task)} down',lg.DEBUG)
                return True
            return False
        elif task == "getVmmap":
            lprint(f'getting {lg.bold("vmmap")} information...',lg.DEBUG)
            self.command2text(p,'start')
            self.getFromVmmap(p,'stack')
            p.close()
            if self.vmmap_info['stack']: 
                lprint(f'task {lg.bold(task)} down',lg.DEBUG)
                return True
            else: False
        elif task == 'testRun':
            lprint(f'checking if the process can be executed...',lg.DEBUG)
            res=self.command2text(p,'start')
            p.close()
            # lprint(res,lg.DEBUG)
            lprint(f'task {lg.bold(task)} down',lg.DEBUG)
            if not res:
                return False
            return True
        
    def checkAddress(self,address):
        if not self.vmmap_info['stack']:
            lprint('vmmap_info not be inited',lg.FAIL)
            exit()
        for name,infos in self.vmmap_info.items():
            for info in infos:
                if address >= int(info[0],16) and address <= int(info[1],16):
                    return (name,info[3])
        return ('none','none')
        
    def getFromStack(self,p,stackInfoCount):
        # stack_info=[[['0x1',('stack','data')],['0x2','ld']]]
        stack_info=[]
        res=self.command2text(p,f'stack {stackInfoCount}')
        for row in res.decode().split('\n')[:-1]:
            infos=[]
            addresses=re.findall('0x[0-9a-f]{1,16}',row)
            for address in addresses:
                info=[]
                info.append(address)
                info.append(self.checkAddress(int(address,16)))
                infos.append(info)
            stack_info.append(infos)

        lprint(res.decode(),lg.DEBUG)
        lprint(res,lg.DEBUG)
        return stack_info

            

    def Attack(self,filepath:str,vulnFuncAddress:int,func_send=None,**kwargs):
        # 测试路径是否正确，并获取文件名称
        if not os.path.exists(filepath): 
            lprint("file not exist!",lg.FAIL)
            return
        self.filename=filepath.split('/')[-1]
        # 更新vmmap_gaadget与vmmap_info
        self.vmmap_gadgets.append('/'+self.filename)
        self.vmmap_info[self.filename]=[]
        lprint(f'filename => {lg.bold(self.filename)}',lg.DEBUG)
        # 测试程序是否可以正常运行
        if not self.taskFunc('testRun',filepath):
            lprint(f'{self.filename} can not be run',lg.FAIL)
            exit()
        # 多线程获取信息
        thread_list=[]
        tasks=['getVmmap','getChecksec']
        for task in tasks:
            t=threading.Thread(target=self.taskFunc,args=(task,filepath,))
            thread_list.append(t)
            t.start()
        # 等待线程池内所有线程完成之后才能向下执行
        while True:
            flag=True
            for t in thread_list:
                # print(t.is_alive())
                if t.is_alive():
                    flag=False
            if flag:break
            time.sleep(0.2)
        # 尝试获取格式化字符串漏洞点
        # 原理：重复发送%p,尝试获取0x开头的结果
        # 打印信息
        # lprint(self.vmmap_info,lg.DEBUG)
        # lprint(self.protect_info,lg.DEBUG)
        # 获取vuln函数地址
        realVulnAddress=0
        if self.protect_info['PIE'] == self.protect_states['PIE'][0]:
            realVulnAddress=int(self.vmmap_info[self.filename][0][0],16)+vulnFuncAddress
        else: realVulnAddress=vulnFuncAddress
        
        # 尝试发送%p
        p=process(f'gdb {filepath}',shell=True)
        self.doCommand(p,f'b *{hex(realVulnAddress)}')
        self.doCommand(p,'run')
        if not func_send:
            lprint(f'you should set {lg.bold("func_send")}')
            exit()
        func_send(p,**kwargs)

        # self.clearText(p)
        stack_info=self.getFromStack(p,30)
        lprint(stack_info,lg.DEBUG)
        


        # p.close()
        # res=comm
        # p.sendline('%p')
        p.interactive()

        # p.interactive()
        

        # print(self.vmmap_info)
        # print(self.protect_info)
        # self.threadFunc('vmmap',filepath)



        # p=process(f'gdb {filepath}',shell=True)
        # self.clearText(p)
        # res=self.command2text(p,'start')
        # print(res)
        # self.command2text(p,'stack 30"',True)
        # self.getFromVmmap(p,'stack')
        # self.getFromChecksec(p,'PIE')


        # p.interactive()